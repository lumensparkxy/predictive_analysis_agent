"""
Vulnerability Scanner for Snowflake Analytics
Security vulnerability scanning and assessment system.
"""

import os
import re
import json
import time
import requests
import subprocess
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from enum import Enum
import hashlib
import threading
import structlog

logger = structlog.get_logger(__name__)


class VulnerabilityType(Enum):
    """Types of vulnerabilities."""
    DEPENDENCY = "dependency"
    CONFIGURATION = "configuration"
    CODE = "code"
    INFRASTRUCTURE = "infrastructure"
    COMPLIANCE = "compliance"


class SeverityLevel(Enum):
    """Vulnerability severity levels."""
    INFORMATIONAL = "informational"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class VulnerabilityScanner:
    """
    Comprehensive vulnerability scanning system.
    Scans dependencies, code, configuration, and infrastructure.
    """
    
    def __init__(self):
        """Initialize vulnerability scanner."""
        self.scan_cache_ttl = int(os.getenv('VULN_SCAN_CACHE_TTL', '3600'))  # 1 hour
        self.scan_cache: Dict[str, Dict[str, Any]] = {}
        self.scan_results_dir = os.getenv('VULN_SCAN_RESULTS', '/opt/analytics/logs/vulnerability_scans')
        
        # External API configurations
        self.nvd_api_key = os.getenv('NVD_API_KEY')
        self.snyk_token = os.getenv('SNYK_TOKEN')
        
        # Create results directory
        os.makedirs(self.scan_results_dir, exist_ok=True)
        
        logger.info("VulnerabilityScanner initialized")
    
    def scan_all(self) -> Dict[str, Any]:
        """Run comprehensive vulnerability scan."""
        scan_id = self._generate_scan_id()
        scan_start = datetime.utcnow()
        
        logger.info("Starting comprehensive vulnerability scan", scan_id=scan_id)
        
        results = {
            'scan_id': scan_id,
            'timestamp': scan_start.isoformat(),
            'scans': {},
            'summary': {
                'total_vulnerabilities': 0,
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'informational': 0
            }
        }
        
        # Run individual scans
        scan_functions = [
            ('dependencies', self.scan_dependencies),
            ('configuration', self.scan_configuration),
            ('code', self.scan_code),
            ('infrastructure', self.scan_infrastructure),
            ('compliance', self.scan_compliance)
        ]
        
        for scan_name, scan_func in scan_functions:
            try:
                logger.info(f"Running {scan_name} scan", scan_id=scan_id)
                scan_result = scan_func()
                results['scans'][scan_name] = scan_result
                
                # Update summary
                for vuln in scan_result.get('vulnerabilities', []):
                    severity = vuln.get('severity', 'informational')
                    results['summary'][severity] += 1
                    results['summary']['total_vulnerabilities'] += 1
                    
            except Exception as e:
                logger.error(f"{scan_name} scan failed", scan_id=scan_id, error=str(e))
                results['scans'][scan_name] = {
                    'status': 'error',
                    'error': str(e),
                    'vulnerabilities': []
                }
        
        # Calculate scan duration
        scan_end = datetime.utcnow()
        results['duration'] = (scan_end - scan_start).total_seconds()
        results['status'] = 'completed'
        
        # Save results
        self._save_scan_results(scan_id, results)
        
        logger.info("Vulnerability scan completed", scan_id=scan_id, 
                   total_vulns=results['summary']['total_vulnerabilities'])
        
        return results
    
    def scan_dependencies(self) -> Dict[str, Any]:
        """Scan for dependency vulnerabilities."""
        try:
            vulnerabilities = []
            
            # Check if we have cached results
            cache_key = 'dependencies'
            if self._is_scan_cached(cache_key):
                return self.scan_cache[cache_key]
            
            # Scan Python dependencies
            python_vulns = self._scan_python_dependencies()
            vulnerabilities.extend(python_vulns)
            
            # Scan JavaScript dependencies (if any)
            js_vulns = self._scan_javascript_dependencies()
            vulnerabilities.extend(js_vulns)
            
            # Scan system packages
            system_vulns = self._scan_system_packages()
            vulnerabilities.extend(system_vulns)
            
            result = {
                'scan_type': 'dependencies',
                'timestamp': datetime.utcnow().isoformat(),
                'vulnerabilities': vulnerabilities,
                'status': 'completed'
            }
            
            # Cache results
            self._cache_scan_results(cache_key, result)
            
            return result
            
        except Exception as e:
            logger.error("Dependency scan failed", error=str(e))
            return {
                'scan_type': 'dependencies',
                'timestamp': datetime.utcnow().isoformat(),
                'status': 'error',
                'error': str(e),
                'vulnerabilities': []
            }
    
    def scan_configuration(self) -> Dict[str, Any]:
        """Scan for configuration vulnerabilities."""
        try:
            vulnerabilities = []
            
            # Check SSL/TLS configuration
            ssl_vulns = self._check_ssl_configuration()
            vulnerabilities.extend(ssl_vulns)
            
            # Check database configuration
            db_vulns = self._check_database_configuration()
            vulnerabilities.extend(db_vulns)
            
            # Check API configuration
            api_vulns = self._check_api_configuration()
            vulnerabilities.extend(api_vulns)
            
            # Check file permissions
            perm_vulns = self._check_file_permissions()
            vulnerabilities.extend(perm_vulns)
            
            return {
                'scan_type': 'configuration',
                'timestamp': datetime.utcnow().isoformat(),
                'vulnerabilities': vulnerabilities,
                'status': 'completed'
            }
            
        except Exception as e:
            logger.error("Configuration scan failed", error=str(e))
            return {
                'scan_type': 'configuration',
                'timestamp': datetime.utcnow().isoformat(),
                'status': 'error',
                'error': str(e),
                'vulnerabilities': []
            }
    
    def scan_code(self) -> Dict[str, Any]:
        """Scan for code vulnerabilities."""
        try:
            vulnerabilities = []
            
            # Static code analysis
            code_vulns = self._scan_code_static()
            vulnerabilities.extend(code_vulns)
            
            # Check for hardcoded secrets
            secret_vulns = self._scan_hardcoded_secrets()
            vulnerabilities.extend(secret_vulns)
            
            # Check for SQL injection patterns
            sql_vulns = self._scan_sql_injection()
            vulnerabilities.extend(sql_vulns)
            
            return {
                'scan_type': 'code',
                'timestamp': datetime.utcnow().isoformat(),
                'vulnerabilities': vulnerabilities,
                'status': 'completed'
            }
            
        except Exception as e:
            logger.error("Code scan failed", error=str(e))
            return {
                'scan_type': 'code',
                'timestamp': datetime.utcnow().isoformat(),
                'status': 'error',
                'error': str(e),
                'vulnerabilities': []
            }
    
    def scan_infrastructure(self) -> Dict[str, Any]:
        """Scan for infrastructure vulnerabilities."""
        try:
            vulnerabilities = []
            
            # Check open ports
            port_vulns = self._check_open_ports()
            vulnerabilities.extend(port_vulns)
            
            # Check service configurations
            service_vulns = self._check_service_configurations()
            vulnerabilities.extend(service_vulns)
            
            # Check firewall rules
            firewall_vulns = self._check_firewall_rules()
            vulnerabilities.extend(firewall_vulns)
            
            return {
                'scan_type': 'infrastructure',
                'timestamp': datetime.utcnow().isoformat(),
                'vulnerabilities': vulnerabilities,
                'status': 'completed'
            }
            
        except Exception as e:
            logger.error("Infrastructure scan failed", error=str(e))
            return {
                'scan_type': 'infrastructure',
                'timestamp': datetime.utcnow().isoformat(),
                'status': 'error',
                'error': str(e),
                'vulnerabilities': []
            }
    
    def scan_compliance(self) -> Dict[str, Any]:
        """Scan for compliance issues."""
        try:
            vulnerabilities = []
            
            # Check GDPR compliance
            gdpr_vulns = self._check_gdpr_compliance()
            vulnerabilities.extend(gdpr_vulns)
            
            # Check security policies
            policy_vulns = self._check_security_policies()
            vulnerabilities.extend(policy_vulns)
            
            # Check audit logging
            audit_vulns = self._check_audit_logging()
            vulnerabilities.extend(audit_vulns)
            
            return {
                'scan_type': 'compliance',
                'timestamp': datetime.utcnow().isoformat(),
                'vulnerabilities': vulnerabilities,
                'status': 'completed'
            }
            
        except Exception as e:
            logger.error("Compliance scan failed", error=str(e))
            return {
                'scan_type': 'compliance',
                'timestamp': datetime.utcnow().isoformat(),
                'status': 'error',
                'error': str(e),
                'vulnerabilities': []
            }
    
    def _scan_python_dependencies(self) -> List[Dict[str, Any]]:
        """Scan Python dependencies for vulnerabilities."""
        vulnerabilities = []
        
        try:
            # Try using safety (pip install safety)
            result = subprocess.run(['safety', 'check', '--json'], 
                                  capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0:
                safety_output = json.loads(result.stdout)
                for vuln in safety_output:
                    vulnerabilities.append({
                        'type': VulnerabilityType.DEPENDENCY.value,
                        'severity': self._map_safety_severity(vuln.get('vulnerability_id')),
                        'title': f"Vulnerable dependency: {vuln.get('package')}",
                        'description': vuln.get('advisory'),
                        'affected_package': vuln.get('package'),
                        'affected_version': vuln.get('installed_version'),
                        'fixed_version': vuln.get('patched_versions'),
                        'cve_id': vuln.get('vulnerability_id'),
                        'source': 'safety'
                    })
        except (subprocess.TimeoutExpired, FileNotFoundError, json.JSONDecodeError):
            logger.warning("Safety scan failed, skipping Python dependency scan")
        
        return vulnerabilities
    
    def _scan_javascript_dependencies(self) -> List[Dict[str, Any]]:
        """Scan JavaScript dependencies for vulnerabilities."""
        vulnerabilities = []
        
        try:
            # Check if package.json exists
            if os.path.exists('package.json'):
                result = subprocess.run(['npm', 'audit', '--json'], 
                                      capture_output=True, text=True, timeout=60)
                
                if result.stdout:
                    audit_data = json.loads(result.stdout)
                    
                    for vuln_id, vuln in audit_data.get('vulnerabilities', {}).items():
                        vulnerabilities.append({
                            'type': VulnerabilityType.DEPENDENCY.value,
                            'severity': vuln.get('severity', 'medium'),
                            'title': vuln.get('title'),
                            'description': vuln.get('overview'),
                            'affected_package': vuln.get('module_name'),
                            'cve_id': vuln.get('cves', []),
                            'source': 'npm_audit'
                        })
        except (subprocess.TimeoutExpired, FileNotFoundError, json.JSONDecodeError):
            logger.debug("NPM audit not available or failed")
        
        return vulnerabilities
    
    def _scan_system_packages(self) -> List[Dict[str, Any]]:
        """Scan system packages for vulnerabilities."""
        vulnerabilities = []
        
        try:
            # Check for outdated packages (Ubuntu/Debian)
            if os.path.exists('/usr/bin/apt'):
                result = subprocess.run(['apt', 'list', '--upgradable'], 
                                      capture_output=True, text=True, timeout=30)
                
                for line in result.stdout.split('\n'):
                    if '/' in line and 'upgradable' in line:
                        package_info = line.split()[0]
                        vulnerabilities.append({
                            'type': VulnerabilityType.DEPENDENCY.value,
                            'severity': SeverityLevel.LOW.value,
                            'title': f"Outdated system package: {package_info}",
                            'description': "System package has available updates",
                            'affected_package': package_info,
                            'source': 'apt'
                        })
        except (subprocess.TimeoutExpired, FileNotFoundError):
            logger.debug("System package scan not available")
        
        return vulnerabilities
    
    def _check_ssl_configuration(self) -> List[Dict[str, Any]]:
        """Check SSL/TLS configuration."""
        vulnerabilities = []
        
        # Check SSL certificate validity
        cert_path = '/etc/nginx/ssl/certificates/analytics.crt'
        if os.path.exists(cert_path):
            try:
                result = subprocess.run(['openssl', 'x509', '-in', cert_path, '-text', '-noout'],
                                      capture_output=True, text=True, timeout=10)
                
                if result.returncode == 0:
                    # Check for weak signature algorithms
                    if 'Signature Algorithm: sha1' in result.stdout:
                        vulnerabilities.append({
                            'type': VulnerabilityType.CONFIGURATION.value,
                            'severity': SeverityLevel.HIGH.value,
                            'title': "Weak SSL certificate signature algorithm",
                            'description': "SSL certificate uses SHA-1 signature algorithm",
                            'source': 'ssl_config'
                        })
                    
                    # Check certificate expiration
                    import re
                    not_after_match = re.search(r'Not After : (.+)', result.stdout)
                    if not_after_match:
                        from datetime import datetime
                        try:
                            not_after_str = not_after_match.group(1)
                            not_after = datetime.strptime(not_after_str.strip(), '%b %d %H:%M:%S %Y %Z')
                            days_until_expiry = (not_after - datetime.utcnow()).days
                            
                            if days_until_expiry < 30:
                                severity = SeverityLevel.CRITICAL.value if days_until_expiry < 7 else SeverityLevel.HIGH.value
                                vulnerabilities.append({
                                    'type': VulnerabilityType.CONFIGURATION.value,
                                    'severity': severity,
                                    'title': "SSL certificate expiring soon",
                                    'description': f"SSL certificate expires in {days_until_expiry} days",
                                    'source': 'ssl_config'
                                })
                        except ValueError:
                            pass
            except subprocess.TimeoutExpired:
                pass
        
        return vulnerabilities
    
    def _check_database_configuration(self) -> List[Dict[str, Any]]:
        """Check database configuration for security issues."""
        vulnerabilities = []
        
        # Check PostgreSQL configuration
        pg_config_path = '/etc/postgresql/*/main/postgresql.conf'
        import glob
        for config_file in glob.glob(pg_config_path):
            try:
                with open(config_file, 'r') as f:
                    config_content = f.read()
                    
                    # Check for insecure settings
                    if 'ssl = off' in config_content:
                        vulnerabilities.append({
                            'type': VulnerabilityType.CONFIGURATION.value,
                            'severity': SeverityLevel.HIGH.value,
                            'title': "Database SSL disabled",
                            'description': "PostgreSQL SSL is disabled",
                            'source': 'db_config'
                        })
                    
                    if 'log_statement = none' in config_content:
                        vulnerabilities.append({
                            'type': VulnerabilityType.CONFIGURATION.value,
                            'severity': SeverityLevel.MEDIUM.value,
                            'title': "Database logging disabled",
                            'description': "PostgreSQL statement logging is disabled",
                            'source': 'db_config'
                        })
            except (IOError, PermissionError):
                pass
        
        return vulnerabilities
    
    def _check_api_configuration(self) -> List[Dict[str, Any]]:
        """Check API configuration for security issues."""
        vulnerabilities = []
        
        # Check for debug mode
        if os.getenv('DEBUG', 'false').lower() == 'true':
            vulnerabilities.append({
                'type': VulnerabilityType.CONFIGURATION.value,
                'severity': SeverityLevel.HIGH.value,
                'title': "Debug mode enabled in production",
                'description': "Application debug mode is enabled",
                'source': 'api_config'
            })
        
        # Check for default secrets
        default_secrets = ['default-secret-change-in-production', 'changeme', 'password']
        jwt_secret = os.getenv('JWT_SECRET_KEY', '')
        if any(default in jwt_secret.lower() for default in default_secrets):
            vulnerabilities.append({
                'type': VulnerabilityType.CONFIGURATION.value,
                'severity': SeverityLevel.CRITICAL.value,
                'title': "Default JWT secret key",
                'description': "JWT secret key appears to be a default value",
                'source': 'api_config'
            })
        
        return vulnerabilities
    
    def _check_file_permissions(self) -> List[Dict[str, Any]]:
        """Check file permissions for security issues."""
        vulnerabilities = []
        
        sensitive_files = [
            '/opt/analytics/config/secrets.env',
            '/opt/analytics/config/production.env',
            '/etc/nginx/ssl/certificates/'
        ]
        
        for file_path in sensitive_files:
            if os.path.exists(file_path):
                try:
                    stat_info = os.stat(file_path)
                    permissions = oct(stat_info.st_mode)[-3:]
                    
                    # Check for overly permissive permissions
                    if permissions.endswith('7') or permissions.endswith('6'):
                        vulnerabilities.append({
                            'type': VulnerabilityType.CONFIGURATION.value,
                            'severity': SeverityLevel.HIGH.value,
                            'title': f"Insecure file permissions: {file_path}",
                            'description': f"File has permissions {permissions} (world accessible)",
                            'source': 'file_permissions'
                        })
                except (OSError, PermissionError):
                    pass
        
        return vulnerabilities
    
    def _scan_code_static(self) -> List[Dict[str, Any]]:
        """Perform static code analysis."""
        vulnerabilities = []
        
        # This would integrate with tools like Bandit for Python
        try:
            result = subprocess.run(['bandit', '-r', 'src/', '-f', 'json'], 
                                  capture_output=True, text=True, timeout=120)
            
            if result.returncode in [0, 1] and result.stdout:  # 1 means issues found
                bandit_output = json.loads(result.stdout)
                
                for result_item in bandit_output.get('results', []):
                    vulnerabilities.append({
                        'type': VulnerabilityType.CODE.value,
                        'severity': result_item.get('issue_severity', 'medium').lower(),
                        'title': result_item.get('test_name'),
                        'description': result_item.get('issue_text'),
                        'file': result_item.get('filename'),
                        'line': result_item.get('line_number'),
                        'source': 'bandit'
                    })
        except (subprocess.TimeoutExpired, FileNotFoundError, json.JSONDecodeError):
            logger.debug("Bandit static analysis not available")
        
        return vulnerabilities
    
    def _scan_hardcoded_secrets(self) -> List[Dict[str, Any]]:
        """Scan for hardcoded secrets in code."""
        vulnerabilities = []
        
        secret_patterns = [
            (r'password\s*=\s*["\']([^"\']+)["\']', 'Hardcoded password'),
            (r'api_key\s*=\s*["\']([^"\']+)["\']', 'Hardcoded API key'),
            (r'secret_key\s*=\s*["\']([^"\']+)["\']', 'Hardcoded secret key'),
            (r'token\s*=\s*["\']([^"\']+)["\']', 'Hardcoded token'),
        ]
        
        # Scan Python files
        for root, dirs, files in os.walk('src/'):
            for file in files:
                if file.endswith('.py'):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r') as f:
                            content = f.read()
                            
                            for pattern, description in secret_patterns:
                                matches = re.finditer(pattern, content, re.IGNORECASE)
                                for match in matches:
                                    vulnerabilities.append({
                                        'type': VulnerabilityType.CODE.value,
                                        'severity': SeverityLevel.HIGH.value,
                                        'title': description,
                                        'description': f"Potential hardcoded secret found in {file_path}",
                                        'file': file_path,
                                        'source': 'secret_scan'
                                    })
                    except (IOError, UnicodeDecodeError):
                        pass
        
        return vulnerabilities
    
    def _scan_sql_injection(self) -> List[Dict[str, Any]]:
        """Scan for SQL injection vulnerabilities."""
        vulnerabilities = []
        
        # Pattern for potential SQL injection
        sql_patterns = [
            r'execute\s*\(\s*["\'].*%.*["\'].*%',
            r'query\s*\(\s*["\'].*\+.*["\']',
            r'raw\s*\(\s*["\'].*format.*["\']'
        ]
        
        for root, dirs, files in os.walk('src/'):
            for file in files:
                if file.endswith('.py'):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r') as f:
                            content = f.read()
                            
                            for pattern in sql_patterns:
                                if re.search(pattern, content, re.IGNORECASE):
                                    vulnerabilities.append({
                                        'type': VulnerabilityType.CODE.value,
                                        'severity': SeverityLevel.HIGH.value,
                                        'title': "Potential SQL injection",
                                        'description': f"Possible SQL injection vulnerability in {file_path}",
                                        'file': file_path,
                                        'source': 'sql_injection_scan'
                                    })
                    except (IOError, UnicodeDecodeError):
                        pass
        
        return vulnerabilities
    
    def _check_open_ports(self) -> List[Dict[str, Any]]:
        """Check for unexpected open ports."""
        vulnerabilities = []
        
        try:
            result = subprocess.run(['ss', '-tulpn'], capture_output=True, text=True, timeout=10)
            
            expected_ports = {'22', '80', '443', '8000', '8501', '5432', '6379'}
            
            for line in result.stdout.split('\n'):
                if 'LISTEN' in line:
                    # Extract port number
                    parts = line.split()
                    if len(parts) >= 5:
                        address = parts[4]
                        if ':' in address:
                            port = address.split(':')[-1]
                            if port not in expected_ports:
                                vulnerabilities.append({
                                    'type': VulnerabilityType.INFRASTRUCTURE.value,
                                    'severity': SeverityLevel.MEDIUM.value,
                                    'title': f"Unexpected open port: {port}",
                                    'description': f"Port {port} is listening and not in expected ports list",
                                    'source': 'port_scan'
                                })
        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass
        
        return vulnerabilities
    
    def _check_service_configurations(self) -> List[Dict[str, Any]]:
        """Check service configurations."""
        vulnerabilities = []
        
        # Check systemd service security settings
        service_files = [
            '/etc/systemd/system/analytics-api.service',
            '/etc/systemd/system/analytics-worker.service',
            '/etc/systemd/system/analytics-scheduler.service'
        ]
        
        for service_file in service_files:
            if os.path.exists(service_file):
                try:
                    with open(service_file, 'r') as f:
                        content = f.read()
                        
                        # Check for security hardening options
                        security_options = [
                            'NoNewPrivileges=true',
                            'ProtectSystem=strict',
                            'PrivateTmp=true'
                        ]
                        
                        missing_options = [opt for opt in security_options if opt not in content]
                        if missing_options:
                            vulnerabilities.append({
                                'type': VulnerabilityType.INFRASTRUCTURE.value,
                                'severity': SeverityLevel.LOW.value,
                                'title': f"Missing security options in {service_file}",
                                'description': f"Service missing security options: {missing_options}",
                                'source': 'service_config'
                            })
                except (IOError, PermissionError):
                    pass
        
        return vulnerabilities
    
    def _check_firewall_rules(self) -> List[Dict[str, Any]]:
        """Check firewall configuration."""
        vulnerabilities = []
        
        try:
            # Check if UFW is active
            result = subprocess.run(['ufw', 'status'], capture_output=True, text=True, timeout=10)
            
            if 'Status: inactive' in result.stdout:
                vulnerabilities.append({
                    'type': VulnerabilityType.INFRASTRUCTURE.value,
                    'severity': SeverityLevel.HIGH.value,
                    'title': "Firewall disabled",
                    'description': "UFW firewall is inactive",
                    'source': 'firewall_check'
                })
        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass
        
        return vulnerabilities
    
    def _check_gdpr_compliance(self) -> List[Dict[str, Any]]:
        """Check GDPR compliance."""
        vulnerabilities = []
        
        # Check for privacy policy
        if not os.path.exists('docs/privacy-policy.md'):
            vulnerabilities.append({
                'type': VulnerabilityType.COMPLIANCE.value,
                'severity': SeverityLevel.MEDIUM.value,
                'title': "Missing privacy policy",
                'description': "No privacy policy document found",
                'source': 'gdpr_compliance'
            })
        
        # Check for data retention policy
        if not os.path.exists('docs/data-retention-policy.md'):
            vulnerabilities.append({
                'type': VulnerabilityType.COMPLIANCE.value,
                'severity': SeverityLevel.MEDIUM.value,
                'title': "Missing data retention policy",
                'description': "No data retention policy document found",
                'source': 'gdpr_compliance'
            })
        
        return vulnerabilities
    
    def _check_security_policies(self) -> List[Dict[str, Any]]:
        """Check security policies."""
        vulnerabilities = []
        
        # Check for security policy files
        required_policies = [
            'src/snowflake_analytics/security/policies/security_policy.yaml',
            'src/snowflake_analytics/security/policies/access_control.yaml'
        ]
        
        for policy_file in required_policies:
            if not os.path.exists(policy_file):
                vulnerabilities.append({
                    'type': VulnerabilityType.COMPLIANCE.value,
                    'severity': SeverityLevel.LOW.value,
                    'title': f"Missing security policy: {policy_file}",
                    'description': f"Security policy file {policy_file} not found",
                    'source': 'security_policies'
                })
        
        return vulnerabilities
    
    def _check_audit_logging(self) -> List[Dict[str, Any]]:
        """Check audit logging configuration."""
        vulnerabilities = []
        
        # Check if audit logging is enabled
        audit_enabled = os.getenv('AUDIT_LOG_ENABLED', 'true').lower() == 'true'
        if not audit_enabled:
            vulnerabilities.append({
                'type': VulnerabilityType.COMPLIANCE.value,
                'severity': SeverityLevel.HIGH.value,
                'title': "Audit logging disabled",
                'description': "Security audit logging is disabled",
                'source': 'audit_compliance'
            })
        
        return vulnerabilities
    
    def _map_safety_severity(self, vuln_id: str) -> str:
        """Map Safety vulnerability severity."""
        # This would map specific CVE IDs to severity levels
        # For now, return medium as default
        return SeverityLevel.MEDIUM.value
    
    def _is_scan_cached(self, cache_key: str) -> bool:
        """Check if scan results are cached and valid."""
        if cache_key not in self.scan_cache:
            return False
        
        cached_time = self.scan_cache[cache_key].get('cached_at', 0)
        return time.time() - cached_time < self.scan_cache_ttl
    
    def _cache_scan_results(self, cache_key: str, results: Dict[str, Any]):
        """Cache scan results."""
        results['cached_at'] = time.time()
        self.scan_cache[cache_key] = results
    
    def _generate_scan_id(self) -> str:
        """Generate unique scan ID."""
        return f"scan_{int(time.time())}_{hashlib.md5(os.urandom(16)).hexdigest()[:8]}"
    
    def _save_scan_results(self, scan_id: str, results: Dict[str, Any]):
        """Save scan results to file."""
        try:
            results_file = os.path.join(self.scan_results_dir, f"{scan_id}.json")
            with open(results_file, 'w') as f:
                json.dump(results, f, indent=2, default=str)
            
            logger.info("Scan results saved", scan_id=scan_id, file=results_file)
        except Exception as e:
            logger.error("Failed to save scan results", scan_id=scan_id, error=str(e))
    
    def get_scan_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get recent scan history."""
        try:
            scan_files = []
            for file_name in os.listdir(self.scan_results_dir):
                if file_name.endswith('.json') and file_name.startswith('scan_'):
                    file_path = os.path.join(self.scan_results_dir, file_name)
                    scan_files.append((file_path, os.path.getmtime(file_path)))
            
            # Sort by modification time (newest first)
            scan_files.sort(key=lambda x: x[1], reverse=True)
            
            scan_history = []
            for file_path, _ in scan_files[:limit]:
                try:
                    with open(file_path, 'r') as f:
                        scan_data = json.load(f)
                        scan_history.append({
                            'scan_id': scan_data.get('scan_id'),
                            'timestamp': scan_data.get('timestamp'),
                            'total_vulnerabilities': scan_data.get('summary', {}).get('total_vulnerabilities', 0),
                            'status': scan_data.get('status')
                        })
                except (json.JSONDecodeError, KeyError):
                    continue
            
            return scan_history
            
        except Exception as e:
            logger.error("Failed to get scan history", error=str(e))
            return []